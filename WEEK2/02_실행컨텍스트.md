### 실행 컨텍스트의 원칙

 1. 전역 컨텍스트 하나 생성 후, 함수 호출 시마다 컨텍스트 생성
 2. 컨텍스트 생성 시 컨텍스트 안에 **변수객체(arguments, variable), scope chain, this**가 생성
 3. 컨텍스트 생성 후 함수가 실행되는데, 사용되는 변수들은 변수 객체 안에서 값을 찾고, 없다면 스코프 체인을 따라 올라가며 찾음
 4. 함수 실행이 마무리되면 해당 컨텍스트는 사라짐.(클로저 제외) 페이지가 종료되면 전역 컨텍스트가 사라짐


# 01. 실행 컨텍스트란?
실행 컨텍스트: 실행할 코드에 제공할 환경 정보들을 모아놓은 객체

➡️ **동일한 환경**에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성
➡️ 이를 **콜 스택(call stack)**에 쌓아올렸다가 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행

❗️'동일한 환경'은 하나의 실행 컨텍스트를 구성할 수 있는 방법. 전역공간, eval() 함수, 함수 등이 있음


    // --------------------- (1)
    var a = 1;
    function outer() {
	    function inner() {
		    console.log(a); // undefined
		    var a = 3;
		}
		inner();   // -----------(2)
		console.log(a); // 1
	}
	outer(); // -------------(3)
	console.log(a);  // 1

 1. 처음 자바스크립트 코드를 실행하는 순간(1), 전역 컨텍스트가 콜 스택에 담김
 2. 전역 컨텍스트와 관련된 코드들을 순차적으로 진행하다가 (3)에서 outer 함수를 호출하면 자바스크립트는 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성한 후 콜 스택에 담음
 3. 콜 스택 맨 위에 outer 실행 컨텍스트가 놓인 상태가 됐으므로 전역 컨텍스트와 관련된 코드는 실행 중단. 그리고 outer 함수 내부의 코드를 순차적으로 실행
 4. 다시 (2)에서 inner 함수의 실행 컨텍스트가 콜 스택의 가장 위에 담기면 outer 코드 실행 중단 후 inner 함수 내부의 코드를 순서대로 진행
 5. inner 함수 내부에서 a 변수에 값 3을 할당하면 inner 함수의 실행이 종료되고 inner 실행 컨텍스트가 콜 스택에서 제거됨. 
 6. outer 실행 컨텍스트가 콜 스택 가장 상단에 위치하면서 (2) 다음 줄부터 이어 실행 후 실행 종료
 7. outer 실행 컨텍스트가 콜 스택에서 제거되고 전역 컨텍스트가 이어 실행 됨. 전역 컨텍스트까지 실행이 종료되면 콜 스택에서 제거되면서 콜 스택에는 아무것도 남지 않은 상태로 종료

## 실행 컨텍스트 객체에 담기는 정보

 - **VariableEnvironment**: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음
 - **LexicalEnvironment**: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨
- **ThisBinding**: 식별자가 바라봐야 할 대상 객체

# 02. VariableEnvironment
- 구성 정보: environmentRecord + outer-EnvironmentReference
- LexicalEnvironment와의 차이점; 담기는 내용은 같지만, variableEnvironment는 최초 실행 시의 스냅샷을 유지한다는 점이 다름

# 03. LexicalEnvironment
## 2-3-1 environmentRecord와 호이스팅
❗️environmentRecord에 담기는 정보: **매개변수 이름, 함수 선언, 변수명** 등
➡️ **변수 정보를 수집하는 과정**에서, 마치 자바스크립트 엔진이 식별자들을 코드의 최상단으로 끌어올려놓고 실제 코드를 실행하는 것 같은 현상이 발생(**hoisting**)
➡️ 이는 environmentRecord에 정보를 미리 저장하여 때문에 자바스크립트 엔진이 코드를 실행하기도 전에 변수명들을 모두 알 수 있기 때문

### 함수 선언문과 함수 표현식
- 함수 선언문: function 정의부만 존재하고 별도의 할당 명령이 없는 것
➡️ 반드시 함수명이 정의돼 있어야 함
- 함수 표현식: 정의한 function을 별도의 변수에 할당하는 것
➡️ 함수명이 정의돼 있지 않아도 괜찮음

```
// 함수를 정의하는 3가지 방식
function a() { /* ... */ } // 함수 선언문. 함수명 a가 곧 변수명
a(); // 실행 OK

var b = function() { /* ... */ } // (익명) 함수 표현식. 변수명 b가 곧 함수명.
b(); // 실행 OK

var c = function d() { /* ... */ } // 기명 함수 표현식. 변수명은 c, 함수명은 d.
c(); // 실행 OK
d(); // 에러!
```
❗️ 기명 함수 표현식의 경우, 외부에서는 함수명으로 함수를 호출할 수 없음

```
// 함수 선언문과 함수 표현식 - 원본 코드
console.log(sum(1,2));
console.log(multiply(3,4));

funtion sum(a, b) {   // 함수 선언문 sum
	return a + b;
}

var multiply = function (a, b) {   // 함수 표현식 multiply
	return a * b;
}
```
```
// 함수 선언문과 함수 표현식 - 호이스팅을 마친 상태
var sum = function sum (a, b) { // 함수 선언문은 전체를 호이스팅함
	return a + b;
};
var multiply;   // 변수는 선언부만 끌어올립니다

console.log(sum(1,2));
console.log(multiply(3,4));

multiply = function (a, b) { // 변수의 할당부는 원래 자리에 남겨둡니다
	return a * b;
}
```
➡️ sum 함수는 선언 전에 호출해도 아무 문제 없이 실행됨(혼란을 일으킬 수 있는 부분)
➡️ 또한, 만약 전역공간에 함수 선언문으로 동명의 함수를 선언했다면 앞의 코드가 덮어씌워지는 일이 발생할 수 있음

## 2-3-2 스코프, 스코프 체인, outerEnvironmentReference
- **스코프(scope)**: 식별자에 대한 유효범위
➡️ 어떤 경계 A의 외부에서 선언한 변수는 A의 외부뿐 아니라 A의 내부에서도 접근이 가능하나, A의 내부에서 선언한 변수는 오직 A의 내부에서만 접근 가능
➡️ JS는 ES5까지 오직 함수에 의해서만 스코프가 생성됐음(전역 공간 제외)
- **스코프 체인(scope chain)**: 식별자의 유효범위를 안에서부터 바깥으로 차례로 검색해 나가는 것
➡️ 이를 가능케 하는 것이 outerEnvironmentReference


### 스코프 체인
outerEnvironmentReference는 현재 호출된 함수가 **선언될 당시**의 LexicalEnvironment를 참조
➡️ outerEnvironmentReference는 연결리스트 형태를 띄게 되고, 선언 시점의 LexicalEnvironment를 계속 찾아 올라가면 마지막엔 전역 컨텍스트의 LexicalEnvironment가 있을 것
➡️ 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능**

### 전역 변수와 지역 변수
- 전역변수: 전역 스코프에서 선언한 변수
- 지역변수: 함수 내부에서 선언한 변수