# 01. 데이터 타입의 종류

- **기본형**: Number, String, Boolean, null, undefined, Symbol

- **참조형**: Array, Function, Date, RegExp, Map, WeakMap, Set, WeakSet

### 기본형과 참조형의 분류기준
기본형은 할당이나 연산 시 복제되고 참조형은 참조된다?
 ➡️ ***기본형은 값이 담긴 주솟값을 바로 복제하는 반면,  참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다!***

# 02. 데이터 타입에 관한 배경지식
## 1-2-1 메모리와 데이터
- 메모리를 비트 단위로 위치를 확인하는 것은 매우 비효율적
- 검색의 효율성과 표현 가능한 갯수를 늘리기 위해 **바이트**라는 단위가 탄생
- 모든 데이터는 바이트 단위의 식별자(**메모리 주솟값**)을 통해 서로 구분이 가능

## 1-2-2 식별자와 변수
- **변수**: 변할 수 있는 무언가(**데이터**)
- **식별자**: 어떤 데이터를 식별하는 데 사용하는 이름, **변수명**

# 03. 변수 선언과 데이터 할당
## 1-3-1 변수 선언

    var a; // 변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다
### 변수 선언에 대한 메모리 영역의 변화
![제목 없는 프레젠테이션 (1)](https://user-images.githubusercontent.com/65005334/204123067-01919bb9-ad98-44af-b908-e56794278b18.png)

 1. 'var a;' 명령을 받은 컴퓨터는 메모리에서 비어있는 공간 하나를 확보
 2. 이 공간의 이름(식별자)을 'a'라고 지정
 
 ➡️ 이후 사용자가 a에 접근하고자 한면 컴퓨터는 메모리에서 a라는 이름을 가진 주소를 검색해 
	 해당 공간에 담긴 데이터를 반환 

## 1-3-2 데이터 할당

    var a;            // 변수 a 선언
    a = 'abc';        // 변수 a에 데이터 할당
    
    var a = 'abc';    // 변수 선언과 할당을 한 문장으로 표현
- 선언과 할당을 두 줄로 나누어 하든, 한 줄로 하든 자바스크립트 엔진 동작 과정은 같음
- 이제 데이터를 할당하고 싶으면 a라는 이름을 가진 주소를 검색해 그 곳에 문자열 'abc'를 할당하면 될까?

❗️**실제로는 해당 위치에 문자열 'abc'를 직접 저장하지 않음**

![제목 없는 프레젠테이션 (3)](https://user-images.githubusercontent.com/65005334/204123830-bd50b581-6a71-4eaa-b0cc-309329f0fb26.png)

❗️**데이터를 저장하기 위한 메모리 공간을 별도로 만들고 데이터 저장 후 그 곳의 주소를 변수영역의 값에 대입**
	
**➡️ 이는 데이터 변환과 중복된 데이터에 대해 메모리를 더욱 효율적으로 관리하기 위함임.**

### 불변성(immutability)
*문자열 'abc' 마지막에 'def'를 추가하려고 한다면?*

➡️ 컴퓨터는 'abc'가 저장된 공간에 'abcdef'를 할당하는 대신, 'abcdef'라는 문자열을 **새로** 만들어 별도의 공간에 저장하고 그 주소를 변수 공간에 연결. 'abc'의 'c'를 제거하는 경우도 'ab'를 새로 만듦
➡️ 따라서 데이터 영역의 'abc'는 불변함

# 04. 기본형 데이터와 참조형 데이터
## 1-4-1 불변값
### 기본형 데이터는 모두 불변값
** cf) 상수(constant): 변수와 달리 바꿀 수 없는 값
### 불변값과 상수의 개념 차이
- 변수와 상수를 구분짓는 변경 가능성의 대상: **변수 영역** 메모리
➡️ 한 번 데이터 할당이 이뤄진 변수 공간에 다른 데이터를 재할당할 수 있는가?

- 불변성 여부를 구분할 때 변경 가능성의 대상: **데이터 영역** 메모리
➡️ 기본형 데이터를 할당할 때, 해당 데이터가 데이터 영역에 이미 있으면 그 주소를 재활용.
➡️ 없으면 데이터 영역에 공간을 하나 만들어 저장.
➡️ 변수의 값을 바꾸려 할 때도 바꾸고자 하는 값이 데이터 영역에 있으면 그 주소를 재활용, 없으면 새로 만듦
➡️ **즉 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않음(불변함)**

## 1-4-2 가변값
❓기본형 데이터는 모두 불변값이니, 참조형 데이터는 모두 가변값일까?
### 참조형 데이터 할당

    var obj1 = {
      a: 1,
      b: 'bbb',
    };
![제목 없는 프레젠테이션 (4)](https://user-images.githubusercontent.com/65005334/204124662-fc5350ab-8093-4844-b132-58f41ad29399.png)

 1. 컴퓨터는 우선 변수 영역의 빈 공간(@1002)을 확보, 그 주소의 이름을 obj1로 지정
 2. 저장해야 하는 데이터가 여러 개의 프로퍼티로 이뤄진 데이터 그룹임. 따라서 **이 그룹 내부의 프로퍼티들을 저장하기 위해 별도의 변수 영역을 마련**하고, 그 영역의 주소(@7103~?)을 임의의 데이터 저장 공간인 @5001에 저장
 3. @7103, @7104에 각각 a, b라는 프로퍼티 이름을 지정
 4. 데이터 영역에서 숫자 1을 검색 후, 있으면 해당 주소를 @7103에 저장, 없으면 임의로 @5003에 저장하고 이 주소를 @7103에 저장. 문자열 'bbb'도 이와 같음

➡️ 기본형 데이터와의 차이는 '객체의 변수 영역'이 별도로 존재한다는 점
➡️ **데이터 영역에 저장된 값은 모두 불변하지만, 변수에는 다른 값을 얼마든지 대입할 수 있기에 흔히 참조형 데이터를 '불변하지 않다'라고 하는 것**
➡️ 가령 'obj.a'를 '1'에서 '2'로 변경하고자 한다면, @5005에 2를 저장하고 @7103의 값을 @5005로 변경함
➡️ 즉 'obj'를 수정하려면 기본형 데이터처럼 새로 데이터를 만들어 @1002의 값을 바꾸는 것이 아니라, 기존 객체 내부의 값만 바꿈

** cf) **참조 카운트**: 어떤 데이터에 대해 자신의 주소를 참조하는 변수의 개수. 참조 카운드가 0인 메모리 주소는 가비지 컬렉터의 수거 대상이 됨
➡️ 'obj1.a'를 '1'에서 '2'로 바꾼 경우, @5003은 참조 카운트가 0이 되므로 수거 대상이 됨

## 1-4-3 변수 복사 비교
❓**변수를 복사할 때 기본형 데이터와 참조형 데이터의 차이**

    var a = 10;
    var b = a;          // 복사
    
    var obj1 = { c: 10, d: 'ddd' };
    var obj2 = obj1;    // 복사

![제목 없는 프레젠테이션 (5)](https://user-images.githubusercontent.com/65005334/204125609-e5a4da61-0696-4e74-8999-c371dd4898b5.png)
➡️ 변수를 복사하는 과정은 기본형, 참조형 데이터 모두 같은 주소를 바라보게 되는 점에서 동일
➡️ 복사 과정은 동일하나, 데이터 할당 과정에서 차이가 있기 때문에 변수 복사 이후의 동작에도 차이 발생


    var a = 10;
    var b = a;          // 복사
    
    var obj1 = { c: 10, d: 'ddd' };
    var obj2 = obj1;    // 복사

    b = 15;
    obj2.c = 20;
    
![제목 없는 프레젠테이션 (6)](https://user-images.githubusercontent.com/65005334/204125951-0fc5e418-4460-4df8-b94f-87de7c81a216.png)

    a !== b         // true
    obj1 === obj2   // true

**➡️ 변수 a와 b는 서로 다른 주소를 바라보게 됐으나, 변수 obj1와 obj2는 여전히 같은 객체를 바라보고 있는 상태**

> 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 점이 
> 기본형과 참조형의 가장 큰 차이

❓내부 프로퍼티(obj2.c)를 변경하지 않고 객체 자체를 변경한다면..
    
    var a = 10;
    var b = a;          
    var obj1 = { c: 10, d: 'ddd' };
    var obj2 = obj1;    

    b = 15;
    obj2 = { c: 20, d: 'ddd' };  // 객체 자체를 변경
❗️메모리 데이터 영역의 새로운 공간에 새 객체가 저장되고 그 주소를 변수 영역의 obj2에 저장하므로, 객체에 대한 변경임에도 값이 달라짐
**➡️ 참조형 데이터가 '가변값'이라는 것은 참조형 데이터 자체를 변경할 경우가 아니라, 그 내부의 프로퍼티를 변경할 때만 성립**
# 05. 불변 객체
## 1-5-1 불변 객체를 만드는 간단한 방법
❗️**참조형 데이터도 프로퍼티가 아닌 데이터 자체를 변경하고자 하면 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않음**
➡️ 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우라면,
**참조형 데이터** 역시 매번 새로운 객체를 만들어 재할당하는 식으로 **불변성 확보가 가능**함을 의미

    var copyObject = function (target) {
	    var result = {};
	    for (var prop in target) {
		    result[prop] = target[prop];   // 얕은 복사
		}
		return result;
    }
➡️ 기존 정보를 복사해서 새로운 객체를 반환하는 함수(얕은 복사)
## 1-5-2 얕은 복사와 깊은 복사
❗️**얕은 복사는 바로 아래 단계의 값만 복사하는 방법이고, 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법**
➡️ 얕은 복사는 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 그 주솟값만 복사함
➡️ 해당 프로퍼티에 대해 원본, 사본 모두 동일한 참조형 데이터 주소를 가리키므로 사본을 바꾸면 원본도 바뀌고, 원본을 바꾸면 사본도 바뀜
➡️ 따라서 기본형 데이터일 경우에는 그대로 복사하면 되지만, 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사해야만 완전히 새로운 객체 데이터를 만들 수 있음

** cf) JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸면 JSON으로 변경할 수 있는 프로퍼티에 한해서는 쉽게 깊은 복사가 가능(메서드나 숨겨진 프로퍼티에 대해서는 불가)

# 06. undefined와 null
❗️자바스크립트의 '**없음**'을 나타내는 값은 **undefined**와 **null** 두 가지가 있음

🔹 **undefined**
➡️ 사용자가 명시적으로 지정할 수도 있으나 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하는 경우도 존재
➡️ 자바스크립트 엔진은 사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환하게 함

 1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
 2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
 3. return 문이 없거나 호출되지 않은 함수의 함수의 실행 결과

### undefined와 배열

    var arr1 = [];
    arr1.length = 3;
    console.log(arr1);     // [empty x 3]
    
    var arr2 = new Array(3);
    console.log(arr2);     // [empty x 3]
    
    var arr3 = [undefined, undefined, undefined];
    console.log(arr3);     // [undefined, undefined, undefined]
    
➡️ arr1, arr2는 undefined조차 할당되지 않음을 의미
➡️ 배열도 객체이기 때문에, 특정 인덱스에 값을 지정할 때 비로소 빈 공간을 확보하고 인덱스를 이름으로 지정하고 데이터의 주솟값을 저장하는 등의 동작을 함(객체의 프로퍼티는 할당없이 선언만 할 수 없음)
➡️ **즉, 값이 지정되지 않은 인덱스는 '아직은 존재하지 않는 프로퍼티'에 지나지 않음**

➡️ 따라서 사용자가 명시적으로 부여한 undefined는 그 자체로 값이지만, 
자바스크립트 엔진이 하는 수 없이 반환해 주는 undefined는 해당 프로퍼티 내지 배열의 인덱스가 존재하지 않음을 의미
➡️ undefined가 혼란을 일으킬 수 있으므로 **'비어있음'을 명시적으로 나타내고 싶을 때**는 undefined가 아닌 **null**을 사용하는 것을 권장

🔹 **null**
➡️ undefined와 마찬가지로 '비어있음'을 의미
➡️ '비어있음'을 명시적으로 나타내고 싶을 때 null만 사용한다면, undefined는 '값을 대입하지 않은 변수에 접근하고자 할 때 자바스크립트 엔진이 반환해주는 값'으로만 한정해 사용이 가능
➡️ 자바스크립트 자체 버그로, typeof null은 object가 반환됨. 
따라서 **해당 값이 null인지 확인하고 싶다면 일치연산자(===)을 사용**할 것

    var n = null;
    console.log(typeof n);           // object
    
    console.log(n == undefined);     // true
    console.log(n == null);          // true
    
    console.log(n === undefined);    // false
    console.log(n === null);         // true 
